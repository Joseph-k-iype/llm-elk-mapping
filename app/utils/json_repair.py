"""
JSON Repair Utility - Fix malformed JSON from LLM responses.

This module provides functions to repair common issues in JSON strings generated by LLMs,
such as missing quotes, trailing commas, and unmatched brackets.
"""

import re
import json
import logging
from typing import Union, Any, Dict, List

logger = logging.getLogger(__name__)

def repair_json(input_str: str) -> str:
    """
    Repair malformed JSON strings commonly returned by LLMs.
    
    Args:
        input_str: The potentially malformed JSON string
        
    Returns:
        Repaired JSON string
    
    Examples:
        >>> repair_json('{"name": "John", "age": 30,}')
        '{"name": "John", "age": 30}'
        
        >>> repair_json('{"items": ["a", "b" "c"]}')
        '{"items": ["a", "b", "c"]}'
    """
    if not input_str:
        return "{}"
    
    # Step 1: Extract JSON content if surrounded by markdown code blocks or other text
    json_content = extract_json_content(input_str)
    
    # Step 2: Apply sequential repairs
    repaired = json_content
    repaired = fix_trailing_commas(repaired)
    repaired = fix_missing_commas(repaired)
    repaired = fix_unquoted_keys(repaired)
    repaired = fix_missing_quotes(repaired)
    repaired = fix_single_quotes(repaired)
    repaired = fix_incorrect_boolean_null(repaired)
    repaired = ensure_balanced_brackets(repaired)
    
    # Step 3: Validate the repaired JSON
    try:
        json.loads(repaired)
        logger.debug("JSON successfully repaired")
        return repaired
    except json.JSONDecodeError as e:
        logger.warning(f"Initial repair failed: {e}")
        
        # Step 4: Try more aggressive repairs if the initial approach failed
        repaired = advanced_json_repair(repaired)
        
        try:
            json.loads(repaired)
            logger.info("JSON repaired successfully with advanced techniques")
            return repaired
        except json.JSONDecodeError as e:
            logger.error(f"Advanced repair also failed: {e}")
            raise ValueError(f"Could not repair JSON: {e}")

def extract_json_content(input_str: str) -> str:
    """
    Extract JSON content from a string that may contain markdown code blocks or other text.
    
    Args:
        input_str: Input string that may contain JSON
        
    Returns:
        Extracted JSON string
    """
    # Check for code blocks with json language specification
    code_block_pattern = r"```(?:json)?\s*([\s\S]*?)\s*```"
    matches = re.findall(code_block_pattern, input_str)
    
    if matches:
        logger.debug("Found JSON in code block")
        return matches[0]
    
    # Look for content that appears to be JSON (starts with { and ends with })
    json_pattern = r"(\{[\s\S]*\})"
    matches = re.findall(json_pattern, input_str)
    
    if matches:
        # Find the largest match by length (most likely to be complete JSON)
        largest_match = max(matches, key=len)
        logger.debug("Extracted JSON content based on braces")
        return largest_match
        
    # If no match found, return the original string
    return input_str

def fix_trailing_commas(input_str: str) -> str:
    """
    Remove trailing commas in objects and arrays which are invalid in JSON.
    
    Args:
        input_str: Input JSON string
        
    Returns:
        Fixed JSON string
    """
    # Fix trailing commas in objects: {"a": 1, "b": 2,} -> {"a": 1, "b": 2}
    input_str = re.sub(r',\s*}', '}', input_str)
    
    # Fix trailing commas in arrays: [1, 2, 3,] -> [1, 2, 3]
    input_str = re.sub(r',\s*]', ']', input_str)
    
    return input_str

def fix_missing_commas(input_str: str) -> str:
    """
    Add missing commas between array elements and object properties.
    
    Args:
        input_str: Input JSON string
        
    Returns:
        Fixed JSON string
    """
    # Fix missing commas in arrays between string values: ["a" "b"] -> ["a", "b"]
    input_str = re.sub(r'"\s+"', '", "', input_str)
    
    # Fix missing commas in arrays between numeric values: [1 2] -> [1, 2]
    input_str = re.sub(r'(\d+)\s+(\d+)', r'\1, \2', input_str)
    
    # Fix missing commas between objects in arrays: [{...} {...}] -> [{...}, {...}]
    input_str = re.sub(r'}\s+{', '}, {', input_str)
    
    return input_str

def fix_unquoted_keys(input_str: str) -> str:
    """
    Add quotes to unquoted object keys.
    
    Args:
        input_str: Input JSON string
        
    Returns:
        Fixed JSON string
    """
    # Add quotes to unquoted object keys: {key: "value"} -> {"key": "value"}
    # This regex matches a word at the beginning of a line or after { or , followed by :
    input_str = re.sub(r'(^|\{|\,)\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*:', r'\1 "\2":', input_str)
    
    return input_str

def fix_missing_quotes(input_str: str) -> str:
    """
    Add missing quotes around string values.
    
    Args:
        input_str: Input JSON string
        
    Returns:
        Fixed JSON string
    """
    # This is a simplified approach - a complete solution would be more complex
    # Add quotes to unquoted string values in objects: {"key": value} -> {"key": "value"}
    # Only applies to simple cases where value is a word (a-z, A-Z, 0-9, _)
    input_str = re.sub(r':\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*(,|})', r': "\1"\2', input_str)
    
    return input_str

def fix_single_quotes(input_str: str) -> str:
    """
    Replace single quotes with double quotes, handling escaping properly.
    
    Args:
        input_str: Input JSON string
        
    Returns:
        Fixed JSON string
    """
    # Replace single quotes with double quotes for keys and string values
    # This is a simplified solution - a complete solution would be more complex
    
    # First escape any existing double quotes
    input_str = input_str.replace('\\"', 'ESCAPED_DOUBLE_QUOTE_TEMP')
    
    # Replace single quotes with double quotes
    input_str = input_str.replace("'", '"')
    
    # Restore escaped double quotes
    input_str = input_str.replace('ESCAPED_DOUBLE_QUOTE_TEMP', '\\"')
    
    return input_str

def fix_incorrect_boolean_null(input_str: str) -> str:
    """
    Fix incorrectly formatted boolean and null values.
    
    Args:
        input_str: Input JSON string
        
    Returns:
        Fixed JSON string
    """
    # Fix capitalized or mixed case boolean and null values
    boolean_replacements = [
        (r'\bTrue\b', 'true'),
        (r'\bFalse\b', 'false'),
        (r'\bNone\b', 'null'),
        (r'\bNULL\b', 'null'),
        (r'\bNull\b', 'null')
    ]
    
    for pattern, replacement in boolean_replacements:
        input_str = re.sub(pattern, replacement, input_str)
    
    return input_str

def ensure_balanced_brackets(input_str: str) -> str:
    """
    Ensure brackets are balanced by adding missing closing brackets or removing extra ones.
    
    Args:
        input_str: Input JSON string
        
    Returns:
        Fixed JSON string with balanced brackets
    """
    # Count opening and closing brackets
    curly_count = 0
    square_count = 0
    in_string = False
    escape_next = False
    
    for char in input_str:
        if escape_next:
            escape_next = False
            continue
        
        if char == '\\':
            escape_next = True
            continue
            
        if char == '"' and not escape_next:
            in_string = not in_string
            continue
        
        if in_string:
            continue
            
        if char == '{':
            curly_count += 1
        elif char == '}':
            curly_count -= 1
        elif char == '[':
            square_count += 1
        elif char == ']':
            square_count -= 1
    
    # Add missing closing brackets
    if curly_count > 0:
        input_str += '}' * curly_count
    elif curly_count < 0:
        # Too many closing curly brackets, remove them from the end
        excess = abs(curly_count)
        input_str = re.sub(r'}$', '', input_str, count=excess)
    
    if square_count > 0:
        input_str += ']' * square_count
    elif square_count < 0:
        # Too many closing square brackets, remove them from the end
        excess = abs(square_count)
        input_str = re.sub(r']$', '', input_str, count=excess)
    
    return input_str

def advanced_json_repair(input_str: str) -> str:
    """
    Apply more aggressive techniques to repair severely malformed JSON.
    
    Args:
        input_str: Input JSON string that failed basic repairs
        
    Returns:
        JSON string repaired with more aggressive techniques
    """
    # Try to reconstruct the JSON from scratch
    try:
        # Approach 1: Try to extract any valid JSON object or array
        pattern = r'(\{(?:[^{}]|(?1))*\}|\[(?:[^\[\]]|(?1))*\])'
        matches = re.findall(pattern, input_str)
        
        if matches:
            # Take the largest match by length
            candidate = max(matches, key=len)
            
            # Apply basic repairs on the extracted candidate
            candidate = fix_trailing_commas(candidate)
            candidate = fix_single_quotes(candidate)
            candidate = fix_incorrect_boolean_null(candidate)
            
            # Try to parse the candidate
            try:
                json.loads(candidate)
                logger.debug("Found valid JSON within malformed string")
                return candidate
            except json.JSONDecodeError:
                pass
        
        # Approach 2: More aggressive replacement of problematic patterns
        repaired = input_str
        
        # Remove any non-JSON content around the main object/array
        repaired = re.sub(r'^[^{\[]*', '', repaired)
        repaired = re.sub(r'[^}\]]*$', '', repaired)
        
        # Fix unmatched quotes (simplistic approach)
        quote_count = repaired.count('"')
        if quote_count % 2 == 1:
            repaired += '"'
        
        # Try one more time with aggressive fixes
        repaired = fix_trailing_commas(repaired)
        repaired = fix_missing_commas(repaired)
        repaired = fix_unquoted_keys(repaired)
        repaired = fix_missing_quotes(repaired)
        repaired = fix_single_quotes(repaired)
        repaired = fix_incorrect_boolean_null(repaired)
        repaired = ensure_balanced_brackets(repaired)
        
        return repaired
        
    except Exception as e:
        logger.error(f"Advanced repair failed with error: {e}")
        # If all else fails, return the input
        return input_str

def loads(input_str: str, default: Union[dict, list, None] = None) -> Any:
    """
    Parse a JSON string, repairing it if necessary.
    
    Args:
        input_str: The potentially malformed JSON string
        default: Default value to return if parsing fails
        
    Returns:
        Parsed JSON object
    """
    if not input_str:
        return default if default is not None else {}
    
    try:
        # First, try normal JSON parsing
        return json.loads(input_str)
    except json.JSONDecodeError:
        try:
            # If that fails, try to repair and parse again
            repaired = repair_json(input_str)
            return json.loads(repaired)
        except (json.JSONDecodeError, ValueError) as e:
            logger.error(f"JSON repair and parsing failed: {e}")
            return default if default is not None else {}